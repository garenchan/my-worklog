# 读书笔记-高性能MySQL

- InnoDB的MVCC(多版本并发控制)，是通过在每行记录后面保存两个隐藏的列来实现的。这
两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是
实际的时间值，而是系统的版本号(system version number)。每开始一个新的事务，系统版
本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行
记录的版本号进行比较。MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作，
其他两个隔离级别都和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是
符合当前事务版本的数据行，而SERIALIZABLE则会对所有读取的行都加锁。

- InnoDB表示基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过它的二级索引
(secondary index，非主键索引)中必须包含主键列，**所以如果主键列很大的话，其他的所有
索引都会很大**。因此，若表上的索引较多的话，主键应当尽可能的小。

- 选择数据类型的原则：
    - 更小的通常更好：占用更少的硬盘、内存和CPU缓存，处理时需要更少的CPU周期。
    - 简单就好：简单数据类型的操作通常需要更少的CPU周期。
    - 尽量避免NULL：查询更难优化，可为NULL的列使得索引、索引统计和值比较都更复杂。

- VARCHAR vs CHAR
    - VARCHAR类型用于存储可变长字符串，比CHAR节省空间，因为仅使用必要的空间；但是
    VARCHAR需要使用1或2个额外字节记录字符串的长度；另外UPDATE时可能导致页分裂，需
    要做额外的工作，并且会产生碎片。
    - CHAR适合存储很短的字符串，或者所有值都接近同一个长度。

- 有一种情况下ORDER BY字句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。

- Percona Toolkit:
    - pt-duplicate-key-checker: 该工具通过分析表结构来找出冗余和重复的索引。
    - pt-index-usage: 该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操
    作，然后打印出关于索引和查询的报告。
    - pt-query-digest: 查询审查review功能，分析其EXPLAIN出来的执行计划。
    - pt-upgrade: 执行每个DSN上的给定MySQL LOGS中的查询，比较结果，并报告任何显著
    差异。
    - pt-query-advisor: 能够解析查询日志、分析查询模式，然后给出所有可能存在潜在
    问题的查询，并给出足够详细的建议。
    - pt-mysql-summary: 方便地总结了MySQL数据库服务器的状态和配置，以便您可以对其
    一目了然。

- 表的数据存储也可能碎片化，有三种类型的数据碎片：
    - 行碎片(Row fragmentation): 这种碎片指的是数据行被存储为多个地方的多个片段中，
    即使查询只从索引中访问一行记录，行碎片也会导致性能下降。
    - 行间碎片(Intra-row fragmentation): 行间碎片是指逻辑上顺序的页，或者行在磁盘
    上不是顺序存储的。行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大的影响，
    因为这些操作原本能够从磁盘上顺序存储的数据中获益。
    - 剩余空间碎片(Free space fragmentation): 剩余空间碎片是指数据页中有大量的空
    余空间。这会导致服务器读取大量不需要的数据，从而造成浪费。

- 在选择索引和编写利用这些索引的查询时，有如下三个原则始终需要记住：
    1. 单行访问是很慢的。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建
    位置引用以提升效率。
    1. 按顺序访问范围数据是很快的。第一，顺序I/O不需要多次磁盘寻道，所以比随机I/O
    要快很多(特别是对机械硬盘)。第二，如果服务器能够按需要顺序读取数据，那么就不
    再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算了。
    1. 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不
    需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。

- 向数据库请求了不需要的数据，会给MySQL服务器带来额外的负担，并增加网络开销，另外
也会消耗应用服务器的CPU和内存资源。典型案例有：
    - 查询不需要的记录：错误地在客户端丢弃MySQL服务端返回的数据
    - 多表关联时返回全部列：只查询需要的列
    - 总是取出全部列：无法使用索引覆盖，对`SELECT *`要持怀疑的态度
    - 重复查询相同的数据：使用缓存进行优化

- 如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优
化它：
    - 使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对
    应行就可以返回结果了。
    - 改变库表结构。例如使用单独的汇总表。
    - 重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。

- 重写查询的方式
    - 一个复杂查询还是多个简单查询
    设计查询的时候一个需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单
    的查询。
    - 切分查询
    分而治之，将大查询切分为小查询。删除旧的数据就是一个很好的例子。定期地清除大
    量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满
    整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大的DELETE语句切
    分成多个较小的查询可以尽可能小地影响MySQL性能，同时还可以减少MySQL复制的延迟。
    - 分解关联查询
    很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查
    询，然后将结果在应用程序中进行关联。用分解关联查询的方式重构查询有如下的优势：
        - 让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。
        - 将查询分解后，执行单个查询可以减少锁的竞争。
        - 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
        - 查询本身效率也可能会有所提升。
        - 可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需
        要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这
        点看，这样的重构还可能会减少网络和内存的消耗。
        - 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环
        关联。某些场景哈希关联的效率要高很多。

- 查询执行路径
    1. 客户端发送一条查询给服务器。
    1. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进
    入下一阶段。
    1. 服务器进行SQL解析、预处理，再由优化器生成对应的执行计划。
    1. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。
    1. 将结果返回给客户端。

![查询执行路径](https://raw.githubusercontent.com/garenchan/my-worklog/master/docs/snapshots/mysql/query_process.png)

- MySQL能够处理的查询优化类型：
    - 重新定义关联表的顺序
    - 将外连接转换成内连接
    - 使用等价变换规则
    - 优化COUNT()、MIN()和MAX()
    - 预估并转化为常数表达式
    - 覆盖索引扫描
    - 子查询优化
    - 提前终止查询
    - 等值传播
    - 列表IN()的比较
    - ......

- **对某个查询执行EXPLAIN EXTENDED后，再执行SHOW WARNINGS，就可以看到重构出的查询**。

- 如果只是使用外键做约束，那通常在应用程序里实现该约束会更好。外键约束会带来很大
的额外消耗。

- 我们通常会希望存储程序越小、越简单越好。希望将更加复杂的处理逻辑交给上层的应用
实现，通常这样会使代码更易读、易维护，也会更灵活。这样做也会让你拥有更多的计算资
源，潜在的还会让你拥有更多的缓存资源。

- 触发器：
    - 可以让你在执行INSERT、UPDATE或DELETE的时候，执行一些特定的操作。
    - 可以在MySQL中指定是在SQL语句执行前触发还是在执行后触发。
    - 触发器本身没有返回值，不过它们可以读取或者改变触发SQL语句所影响的数据。所以
    可以使用触发器实现一些强制限制，或者某些业务逻辑，否则，就需要在应用程序中实
    现这些逻辑。
    - 触发器是“基于行的触发”。
    - 对于BEFORE触发器除了处理的第一条记录，触发器函数ROW_COUNT()总是返回1。可以
    使用这个特点，使得触发器不再是针对每一行都运行，而是针对一条SQL语句运行一次。
    ```sql
        CREATE TRIGGER fake_statement_trigger
        BEFORE INSERT ON sometable
        FOR EACH ROW
        BEGIN
            DECLARE v_row_count INT DEFAULT ROW_COUNT();
            IF v_row_count <> 1 TEHN
                -- Your code here
            END IF;
        END;
    ```

- 事件：
    - 它类似于Linux的定时任务，不过是完全在MySQL内部实现的。你可以创建事件，指定
    MySQL在某个时候执行一段SQL代码，或者每隔一个时间间隔执行一段SQL代码。通常，我
    们会把复杂的SQL都封装到一个存储过程中，这样事件在执行的时候只需要做一个简单的
    CALL调用。
    - 事件在一个独立事件调度线程中被初始化，这个线程和处理连接的线程没有任何关系。
    它不接受任何参数，也没有任何的返回值。可以在MySQL的日志中看到命令的执行日志，
    还可以在表INFORMATION_SCHEMA.EVENTS中看到各个事件状态，例如这个事件最后一次被
    执行的时间等。
